version: '3'

vars:
  BINARY_CORE: memofy-core
  BINARY_UI: memofy-ui
  INSTALL_DIR: '{{.HOME}}/.local/bin'
  VERSION:
    sh: git describe --tags --always --dirty 2>/dev/null || echo "v0.1.0-dev"
  REPO_OWNER: tiroq
  REPO_NAME: memofy

tasks:
  default:
    desc: Show available tasks
    cmds:
      - task --list

  build:
    desc: Build both core and UI binaries
    cmds:
      - task: build-core
      - task: build-ui

  build-core:
    desc: Build the core daemon binary
    sources:
      - cmd/memofy-core/**/*.go
      - internal/**/*.go
      - pkg/**/*.go
    generates:
      - build/{{.BINARY_CORE}}
    cmds:
      - mkdir -p build
      - go build -ldflags "-X main.Version={{.VERSION}}" -o build/{{.BINARY_CORE}} ./cmd/memofy-core

  build-ui:
    desc: Build the menu bar UI binary
    sources:
      - cmd/memofy-ui/**/*.go
      - internal/**/*.go
      - pkg/**/*.go
    generates:
      - build/{{.BINARY_UI}}
    cmds:
      - mkdir -p build
      - go build -ldflags "-X main.Version={{.VERSION}}" -o build/{{.BINARY_UI}} ./cmd/memofy-ui

  install:
    desc: Install binaries and LaunchAgent
    deps: [build]
    cmds:
      - mkdir -p {{.INSTALL_DIR}}
      - cp build/{{.BINARY_CORE}} {{.INSTALL_DIR}}/
      - cp build/{{.BINARY_UI}} {{.INSTALL_DIR}}/
      - chmod +x {{.INSTALL_DIR}}/{{.BINARY_CORE}}
      - chmod +x {{.INSTALL_DIR}}/{{.BINARY_UI}}
      - bash scripts/install-launchagent.sh
      - echo "‚úì Installed to {{.INSTALL_DIR}}"

  uninstall:
    desc: Uninstall binaries and LaunchAgent
    cmds:
      - bash scripts/uninstall.sh

  test:
    desc: Run all tests
    cmds:
      - go test -timeout 30s -v ./...

  test-integration:
    desc: Run integration tests
    cmds:
      - go test -timeout 30s -v ./tests/integration/...

  test-coverage:
    desc: Run tests with coverage report
    cmds:
      - go test -coverprofile=coverage.out ./...
      - go tool cover -html=coverage.out -o coverage.html
      - 'echo "Coverage report: coverage.html"'

  lint:
    desc: Run linter
    cmds:
      - |
        if command -v golangci-lint >/dev/null 2>&1; then
          golangci-lint run ./...
        else
          echo "‚ö†Ô∏è  golangci-lint not installed, using go vet instead"
          echo "üí° Install golangci-lint with: task lint-install"
          go vet ./...
        fi

  lint-install:
    desc: Install golangci-lint
    cmds:
      - |
        if command -v golangci-lint >/dev/null 2>&1; then
          echo "‚úì golangci-lint already installed"
          golangci-lint version
        elif command -v brew >/dev/null 2>&1; then
          echo "‚Üí Installing golangci-lint via Homebrew..."
          brew install golangci-lint
        else
          echo "‚Üí Installing golangci-lint via go install..."
          go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
          echo "‚úì Installed golangci-lint to $(go env GOPATH)/bin/golangci-lint"
          echo "üí° Make sure $(go env GOPATH)/bin is in your PATH"
        fi

  fmt:
    desc: Format code
    cmds:
      - go fmt ./...

  clean:
    desc: Clean build artifacts
    cmds:
      - rm -rf build/
      - rm -rf dist/
      - rm -f coverage.out coverage.html

  # Release tasks
  
  release-local:
    desc: Build release binaries for macOS only (local testing)
    cmds:
      - bash scripts/build-release.sh {{.VERSION}} --macos-only

  release-local-all:
    desc: Build release binaries for all platforms (local testing)
    cmds:
      - bash scripts/build-release.sh {{.VERSION}} --all-platforms

  release-check:
    desc: Check if ready for release (tests, lint, clean git)
    cmds:
      - echo "‚Üí Running tests..."
      - task: test
      - echo "‚Üí Running linter..."
      - task: lint
      - echo "‚Üí Checking git status..."
      - |
        if [ -n "$(git status --porcelain)" ]; then
          echo "‚ùå Git working directory is not clean. Commit or stash changes."
          exit 1
        fi
      - echo "‚Üí Checking git branch..."
      - |
        BRANCH=$(git rev-parse --abbrev-ref HEAD)
        if [ "$BRANCH" != "main" ]; then
          echo "‚ö†Ô∏è  Warning: Not on main branch (currently on $BRANCH)"
        fi
      - echo "‚úì Ready for release"

  release-tag:
    desc: 'Create and push a release tag (auto-bumps patch if no VERSION provided)'
    deps: [release-check]
    vars:
      TAG_VERSION:
        sh: |
          if [ -n "{{.VERSION}}" ]; then
            echo "{{.VERSION}}"
            exit 0
          fi
          latest=$(git tag -l 'v[0-9]*.[0-9]*.[0-9]*' | sort -V | tail -1)
          latest=${latest#v}
          if [ -z "$latest" ]; then
            echo "v0.0.1"
            exit 0
          fi
          major=$(echo "$latest" | cut -d. -f1)
          minor=$(echo "$latest" | cut -d. -f2)
          patch=$(echo "$latest" | cut -d. -f3)
          patch=$((patch+1))
          echo "v$major.$minor.$patch"
    preconditions:
      - sh: 'echo "{{.TAG_VERSION}}" | grep -qE "^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?$"'
        msg: 'VERSION must follow semantic versioning: v0.2.0 or v0.2.0-rc1'
    cmds:
      - echo "‚Üí Creating tag {{.TAG_VERSION}}..."
      - git tag -a {{.TAG_VERSION}} -m "Release {{.TAG_VERSION}}"
      - echo "‚Üí Pushing tag to GitHub..."
      - git push origin main {{.TAG_VERSION}}
      - echo "‚úì Tag {{.TAG_VERSION}} created and pushed"
      - echo "‚úì GitHub Actions will now build and publish the release"
      - 'echo "‚Üí View workflow: https://github.com/{{.REPO_OWNER}}/{{.REPO_NAME}}/actions"'
      - task: release-verify
        vars:
          VERSION: '{{.TAG_VERSION}}'

  release-verify:
    desc: 'Verify release workflow succeeded (auto-detects latest tag if no VERSION provided)'
    vars:
      CHECK_VERSION:
        sh: |
          if [ -n "{{.VERSION}}" ]; then
            echo "{{.VERSION}}"
          else
            git describe --tags --abbrev=0 2>/dev/null || echo ""
          fi
    preconditions:
      - sh: '[ -n "{{.CHECK_VERSION}}" ]'
        msg: 'No VERSION provided and no tags found in repository'
    cmds:
      - |
        if ! command -v gh >/dev/null 2>&1; then
          echo "‚ùå GitHub CLI (gh) is required for release verification."
          echo "   Install from: https://cli.github.com/"
          exit 1
        fi
        # Get repo owner/name from git remote
        repo=$(gh repo view --json nameWithOwner -q .nameWithOwner 2>/dev/null || git config --get remote.origin.url | sed -E 's|.*/([^/]+/[^/]+)(\.git)?$|\1|')
        echo "‚Üí Waiting for release workflow to start for {{.CHECK_VERSION}}..."
        # Give GitHub a moment to register the push before polling
        sleep 8
        attempts=0
        run_id=""
        # Get the commit SHA the tag points to, for fallback matching
        tag_sha=$(git rev-list -n1 "{{.CHECK_VERSION}}" 2>/dev/null || echo "")
        while [ $attempts -lt 60 ]; do
          # Primary: match by head_branch (tag name)
          run_id=$(gh api "repos/$repo/actions/workflows/release.yml/runs?event=push&per_page=20" \
            --jq '.workflow_runs[] | select(.head_branch == "{{.CHECK_VERSION}}") | .id' \
            | head -1)
          # Fallback: match by head SHA when GitHub hasn't set head_branch yet
          if [ -z "$run_id" ] && [ -n "$tag_sha" ]; then
            run_id=$(gh api "repos/$repo/actions/workflows/release.yml/runs?event=push&per_page=20" \
              --jq --arg sha "$tag_sha" '.workflow_runs[] | select(.head_sha == $sha) | .id' \
              | head -1)
          fi
          if [ -n "$run_id" ]; then
            break
          fi
          attempts=$((attempts+1))
          sleep 5
        done
        if [ -z "$run_id" ]; then
          echo "‚ùå Could not find a release workflow run for {{.CHECK_VERSION}}."
          exit 1
        fi
        echo "‚Üí Monitoring release workflow run $run_id..."
        while true; do
          run_data=$(gh api "repos/$repo/actions/runs/$run_id")
          status=$(echo "$run_data" | jq -r '.status')
          conclusion=$(echo "$run_data" | jq -r '.conclusion')
          if [ "$status" = "completed" ]; then
            if [ "$conclusion" = "success" ]; then
              echo "‚úì Release workflow succeeded for {{.CHECK_VERSION}}."
              exit 0
            fi
            echo "‚ùå Release workflow failed for {{.CHECK_VERSION}} (conclusion: $conclusion)."
            gh run view "$run_id" --web || true
            exit 1
          fi
          sleep 10
        done

  release-major:
    desc: 'Auto-bump major version and release (no args)'
    vars:
      NEXT_VERSION:
        sh: |
          latest=$(git tag -l 'v[0-9]*.[0-9]*.[0-9]*' | sort -V | tail -1)
          latest=${latest#v}
          if [ -z "$latest" ]; then
            echo "1.0.0"
            exit 0
          fi
          major=$(echo "$latest" | cut -d. -f1)
          minor=$(echo "$latest" | cut -d. -f2)
          patch=$(echo "$latest" | cut -d. -f3)
          major=$((major+1))
          minor=0
          patch=0
          echo "$major.$minor.$patch"
    cmds:
      - task: release-tag
        vars:
          VERSION: 'v{{.NEXT_VERSION}}'

  release-minor:
    desc: 'Auto-bump minor version and release (no args)'
    vars:
      NEXT_VERSION:
        sh: |
          latest=$(git tag -l 'v[0-9]*.[0-9]*.[0-9]*' | sort -V | tail -1)
          latest=${latest#v}
          if [ -z "$latest" ]; then
            echo "0.1.0"
            exit 0
          fi
          major=$(echo "$latest" | cut -d. -f1)
          minor=$(echo "$latest" | cut -d. -f2)
          patch=$(echo "$latest" | cut -d. -f3)
          minor=$((minor+1))
          patch=0
          echo "$major.$minor.$patch"
    cmds:
      - task: release-tag
        vars:
          VERSION: 'v{{.NEXT_VERSION}}'

  release-patch:
    desc: 'Auto-bump patch version and release (no args)'
    vars:
      NEXT_VERSION:
        sh: |
          latest=$(git tag -l 'v[0-9]*.[0-9]*.[0-9]*' | sort -V | tail -1)
          latest=${latest#v}
          if [ -z "$latest" ]; then
            echo "0.0.1"
            exit 0
          fi
          major=$(echo "$latest" | cut -d. -f1)
          minor=$(echo "$latest" | cut -d. -f2)
          patch=$(echo "$latest" | cut -d. -f3)
          patch=$((patch+1))
          echo "$major.$minor.$patch"
    cmds:
      - task: release-tag
        vars:
          VERSION: 'v{{.NEXT_VERSION}}'

  release-alpha:
    desc: 'Auto-create next alpha tag from latest stable (no args)'
    vars:
      BASE_VERSION:
        sh: |
          latest=$(git tag -l 'v[0-9]*.[0-9]*.[0-9]*' | sort -V | tail -1)
          latest=${latest#v}
          if [ -z "$latest" ]; then
            echo "0.1.0"
            exit 0
          fi
          IFS=. read -r major minor patch <<EOF
          $latest
          EOF
          patch=$((patch+1))
          echo "$major.$minor.$patch"
      NEXT_VERSION:
        sh: |
          base="{{.BASE_VERSION}}"
          latest=$(git tag -l "v${base}-alpha*" | sort -V | tail -1)
          if [ -z "$latest" ]; then
            echo "v${base}-alpha1"
            exit 0
          fi
          n=${latest##*alpha}
          n=$((n+1))
          echo "v${base}-alpha${n}"
    cmds:
      - task: release-tag
        vars:
          VERSION: '{{.NEXT_VERSION}}'

  release-beta:
    desc: 'Auto-create next beta tag from latest stable (no args)'
    vars:
      BASE_VERSION:
        sh: |
          latest=$(git tag -l 'v[0-9]*.[0-9]*.[0-9]*' | sort -V | tail -1)
          latest=${latest#v}
          if [ -z "$latest" ]; then
            echo "0.1.0"
            exit 0
          fi
          major=$(echo "$latest" | cut -d. -f1)
          minor=$(echo "$latest" | cut -d. -f2)
          patch=$(echo "$latest" | cut -d. -f3)
          patch=$((patch+1))
          echo "$major.$minor.$patch"
      NEXT_VERSION:
        sh: |
          base="{{.BASE_VERSION}}"
          latest=$(git tag -l "v${base}-beta*" | sort -V | tail -1)
          if [ -z "$latest" ]; then
            echo "v${base}-beta1"
            exit 0
          fi
          n=${latest##*beta}
          n=$((n+1))
          echo "v${base}-beta${n}"
    cmds:
      - task: release-tag
        vars:
          VERSION: '{{.NEXT_VERSION}}'

  release-stable:
    desc: 'Auto-promote latest prerelease to stable, or bump patch if no prerelease exists'
    vars:
      NEXT_STABLE:
        sh: |
          # Check for latest prerelease (rc, beta, alpha)
          prerelease=$(git tag -l 'v[0-9]*.[0-9]*.[0-9]*-*' | sort -V | tail -1)
          if [ -n "$prerelease" ]; then
            # Strip prerelease suffix to get stable version
            echo "${prerelease%%-*}"
            exit 0
          fi
          # No prerelease, bump patch from latest stable
          latest=$(git tag -l 'v[0-9]*.[0-9]*.[0-9]*' | sort -V | tail -1)
          latest=${latest#v}
          if [ -z "$latest" ]; then
            echo "v0.1.0"
            exit 0
          fi
          major=$(echo "$latest" | cut -d. -f1)
          minor=$(echo "$latest" | cut -d. -f2)
          patch=$(echo "$latest" | cut -d. -f3)
          patch=$((patch+1))
          echo "v$major.$minor.$patch"
    cmds:
      - task: release-tag
        vars:
          VERSION: '{{.NEXT_STABLE}}'

  release-rc:
    desc: 'Auto-create next RC tag (increments RC number or creates rc1 for next patch)'
    vars:
      BASE_VERSION:
        sh: |
          latest=$(git tag -l 'v[0-9]*.[0-9]*.[0-9]*' | sort -V | tail -1)
          latest=${latest#v}
          if [ -z "$latest" ]; then
            echo "0.1.0"
            exit 0
          fi
          major=$(echo "$latest" | cut -d. -f1)
          minor=$(echo "$latest" | cut -d. -f2)
          patch=$(echo "$latest" | cut -d. -f3)
          patch=$((patch+1))
          echo "$major.$minor.$patch"
      NEXT_RC:
        sh: |
          base="{{.BASE_VERSION}}"
          latest=$(git tag -l "v${base}-rc*" | sort -V | tail -1)
          if [ -z "$latest" ]; then
            echo "v${base}-rc1"
            exit 0
          fi
          n=${latest##*rc}
          n=$((n+1))
          echo "v${base}-rc${n}"
    cmds:
      - task: release-tag
        vars:
          VERSION: '{{.NEXT_RC}}'

  release-delete:
    desc: 'Delete a release tag (local and remote) (usage: task release-delete VERSION=v0.2.0)'
    preconditions:
      - sh: '[ -n "{{.VERSION}}" ]'
        msg: 'VERSION variable is required. Usage: task release-delete VERSION=v0.2.0'
    cmds:
      - echo "‚Üí Deleting local tag {{.VERSION}}..."
      - git tag -d {{.VERSION}} || true
      - echo "‚Üí Deleting remote tag {{.VERSION}}..."
      - git push origin :{{.VERSION}} || true
      - echo "‚úì Tag {{.VERSION}} deleted"

  release-list:
    desc: List all tags/releases
    cmds:
      - 'echo "All tags:"'
      - git tag -l | sort -V

  release-status:
    desc: Check GitHub Actions workflow status
    cmds:
      - 'echo "Recent workflow runs:"'
      - gh run list --limit 5 || echo "Install GitHub CLI (gh) to view workflow status"

  # Development tasks

  dev-daemon:
    desc: Run daemon in foreground for development
    cmds:
      - go run ./cmd/memofy-core

  dev-ui:
    desc: Run UI in foreground for development
    cmds:
      - go run ./cmd/memofy-ui

  dev-watch:
    desc: Watch for changes and rebuild
    cmds:
      - |
        echo "Watching for changes... (press Ctrl+C to stop)"
        while true; do
          inotifywait -r -e modify ./cmd ./internal ./pkg 2>/dev/null || fswatch -o ./cmd ./internal ./pkg | read
          echo "‚Üí Rebuilding..."
          task build
        done

  # Utility tasks

  deps:
    desc: Download and verify dependencies
    cmds:
      - go mod download
      - go mod verify

  deps-update:
    desc: Update dependencies
    cmds:
      - go get -u ./...
      - go mod tidy

  deps-vendor:
    desc: Vendor dependencies
    cmds:
      - go mod vendor

  logs:
    desc: View daemon logs
    cmds:
      - tail -f /tmp/memofy-core.out.log

  logs-ui:
    desc: View UI logs
    cmds:
      - tail -f ~/.cache/memofy/memofy-ui.log

  logs-error:
    desc: View daemon error logs
    cmds:
      - tail -f /tmp/memofy-core.err.log

  status:
    desc: Check daemon and UI status
    cmds:
      - 'echo "‚Üí LaunchAgent status:"'
      - launchctl list | grep memofy || echo "  Not running"
      - echo ""
      - 'echo "‚Üí Process status:"'
      - ps aux | grep memofy | grep -v grep || echo "  No processes found"
      - echo ""
      - 'echo "‚Üí Binary locations:"'
      - ls -la {{.INSTALL_DIR}}/memofy-* 2>/dev/null || echo "  Not installed"

  restart:
    desc: Restart daemon and UI
    cmds:
      - launchctl unload ~/Library/LaunchAgents/com.memofy.core.plist 2>/dev/null || true
      - sleep 1
      - launchctl load ~/Library/LaunchAgents/com.memofy.core.plist
      - echo "‚úì Daemon restarted"

  stop:
    desc: Stop daemon
    cmds:
      - launchctl unload ~/Library/LaunchAgents/com.memofy.core.plist 2>/dev/null || true
      - echo "‚úì Daemon stopped"

  start:
    desc: Start daemon
    cmds:
      - launchctl load ~/Library/LaunchAgents/com.memofy.core.plist
      - echo "‚úì Daemon started"

  # CI/CD simulation tasks

  ci-test:
    desc: Simulate CI test workflow
    cmds:
      - task: fmt
      - task: lint
      - task: test
      - task: test-integration

  ci-build:
    desc: Simulate CI build workflow
    cmds:
      - task: build
      - echo "‚úì Build successful"

  # Quick install

  quick-install:
    desc: Run quick install script
    cmds:
      - bash scripts/quick-install.sh

  # Documentation tasks

  docs-serve:
    desc: Serve documentation locally
    cmds:
      - 'echo "Documentation files:"'
      - ls -1 docs/*.md
      - echo ""
      - echo "Open in browser or use a markdown viewer"

  docs-check:
    desc: Check documentation links
    cmds:
      - |
        echo "Checking for broken links in documentation..."
        find docs -name "*.md" -exec grep -H "\.md" {} \; | grep -v "http" || echo "No local markdown links found"
